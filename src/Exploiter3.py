import random
import matplotlib.pyplot as plt
import numpy as np


power_table = np.array(  [[60,20,32],
                                [72,31,50],
                                [45,72,51]],dtype=float)

'''
power_table = np.array([[1,0,2],
                            [2,1,0],
                            [0,2,1]], dtype=float)
'''
'''
power_table = np.array([[1,0,4],    # 0.25, 0.50, 025 lik powertable
                            [2,1,0],
                            [0,2,1]], dtype=float)
'''
'''
power_table = np.array(  [[60,20,42],   # 0.22, 0.19, 0.59 luk powertable
                                [72,31,50],
                                [25,72,51]],dtype=float)
'''
def main():
    optimize()
    #test(steps=100, batch=1000, lr=0.00003)  # e1
    #test(steps=100, batch=1000, lr=0.0000005) #e2
    test(steps=250, batch=1000, lr=0.0000003)  # e3
    #test(steps=100, batch=1000, lr=0.00001)  # e4












payoff = power_table - power_table.transpose()
print("initial payoff",payoff)
size=3
dr = np.ones(size)*1.0/size
army_combinations = np.identity(size)
lr = 0.01
def update():
    global power_table
    powers = np.zeros(len(army_combinations))
    grad_matrix = np.zeros(power_table.shape)
    dr = [0.5, 0.3, 0.2]
    for i,atk in enumerate(army_combinations):
        ap = np.outer(atk,dr)
        dp = np.outer(dr,atk)
        influence = ap-dp
        power = (power_table * influence).sum()
        powers[i] = power
        grad_matrix += influence * power

    err = (powers**2).sum()
    power_table -= lr*grad_matrix
    return err

def optimize():
    global payoff
    err = update()
    while err>0.0001:
        err = update()
    payoff = power_table - power_table.transpose()
    print("optimized payoff", payoff)
    print("optimized powertable", power_table)

# reward(payoff): (win, tie, lose)
def fight(p1_action, p2_action):
    powerdif = power_table[p1_action][p2_action] - power_table[p2_action][p1_action]
    return powerdif / 2

def test(steps=100, batch=1000,lr=0.001):
    nums = [0, 1, 2]
    strategy = np.array([0.1, 0.1, 0.8])

    x = []
    y = [[], [], []]
    addPoint(x, y, strategy)
    for step in range(steps):
        err = [0, 0, 0]
        for i in nums:
            p1moves = random.choices(nums, strategy, k=batch)
            for j in p1moves:
                res = fight(i, j)
                err[i] += res

        grad = calcGrad(err, greedy=True)

        strategy = strategy - grad * lr
        strategy = intoProb(strategy)
        addPoint(x, y, strategy)
    print("strategy",strategy)
    plt.plot(x, y[0], label='rock')
    plt.plot(x, y[1], label='paper')
    plt.plot(x, y[2], label='scissors')
    plt.legend()
    plt.ylim(-0.03,1.05)
    plt.xlabel("iteration")
    plt.ylabel("probability")
    plt.show()

def calcGrad(err, greedy=True):
    if greedy:
        maxerr = max(err)
        row = err.index(maxerr)
        grad = payoff[row]*maxerr
    else:
        grad = [0, 0, 0]
        for i in range(3):
            grad += payoff[i] * err[i]
    return grad

def intoProb(vals):
    vals[vals<0]=0
    total = sum(vals)
    return vals/total

xctr=0
def addPoint(x,y,s):
    global xctr
    x.append(xctr)
    xctr = xctr+1
    y[0].append(s[0])
    y[1].append(s[1])
    y[2].append(s[2])

if __name__ == '__main__':
    np.set_printoptions(precision=2)
    main()
