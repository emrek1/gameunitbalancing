import random
import matplotlib.pyplot as plt
import numpy as np
from timeit import default_timer as timer


size = 50
power_table = np.random.rand(size,size)




def main():
    t0 = timer()
    optimize()
    t1 = timer()
    test(steps=200, batch=1000, lr=0.0001)  #e8-9
    t2 = timer()
    print("optimize:",t1-t0)
    print("simulate:", t2 - t1)





payoff = power_table - power_table.transpose()
print("first",payoff)
dr = np.ones(size)*1.0/size
army_combinations = np.identity(size)
lr = 0.1
def update():
    global power_table
    powers = np.zeros(len(army_combinations))
    grad_matrix = np.zeros(power_table.shape)

    for i,atk in enumerate(army_combinations):
        ap = np.outer(atk,dr)
        dp = np.outer(dr,atk)
        influence = ap-dp
        power = (power_table * influence).sum()
        powers[i] = power
        grad_matrix += influence * power


    err = (powers**2).sum()
    power_table -= lr*grad_matrix
    return err

def optimize():
    global payoff
    err = update()
    while err>0.0001:
        err = update()
    payoff = power_table - power_table.transpose()
    print("optimized payoff", payoff)

# reward(payoff): (win, tie, lose)
def fight(p1_action, p2_action):
    powerdif = power_table[p1_action][p2_action] - power_table[p2_action][p1_action]
    return powerdif / 2

def test(steps=100, batch=1000,lr=0.001):
    nums = list(range(0,size))
    strategy = np.random.rand(size)
    strategy = intoProb(strategy)
    strategy = np.ones(size)*1.0/size   # equal strategy
    x = []
    y = []
    for i in range(size):
        y.append([])
    addPoint(x, y, strategy)
    for step in range(steps):
        err = np.zeros(size)
        for i in nums:
            p1moves = random.choices(nums, strategy, k=batch)
            for j in p1moves:
                res = fight(i, j)
                err[i] += res

        grad = calcGrad(err, greedy=True)

        strategy = strategy - grad * lr
        strategy = intoProb(strategy)

        addPoint(x, y, strategy)

    print("strategy",strategy)

    for i in range(size):
        plt.plot(x, y[i])
    plt.ylim(-0.003,0.1)
    plt.xlabel("iteration")
    plt.ylabel("probability")
    plt.show()

def calcGrad(err, greedy=True):
    if greedy:
        row = err.argmax()
        grad = payoff[row] * err.max()
    else:
        grad = [0, 0, 0, 0, 0]
        for i in range(5):
            grad += payoff[i] * err[i]

    return grad

def intoProb(vals):
    vals[vals<0]=0
    total = sum(vals)
    return vals/total

xctr=0
def addPoint(x,y,s):
    global xctr
    x.append(xctr)
    xctr = xctr+1
    for i in range(size):
        y[i].append(s[i])


if __name__ == '__main__':
    np.set_printoptions(precision=2)
    main()
