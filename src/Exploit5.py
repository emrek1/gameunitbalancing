import random
import matplotlib.pyplot as plt
import numpy as np
from timeit import default_timer as timer


# Probability model
power_table = np.array(  [[10,90,62,22,15],
                                [72,31,80,65,22],
                                [35,52,71,87,32],
                                [90,12,10,54,58],
                                [20,51,76,14,88]],dtype=float)
print(power_table)
def main():
    t0 = timer()
    optimize()
    t1 = timer()
    #test(steps=100, batch=1000, lr=0.0000003)  # e5
    test(steps=100, batch=1000, lr=0.00000003)  #e7
    t2 = timer()
    print("optimize:",t1-t0)
    print("simulate:", t2 - t1)






payoff = power_table - power_table.transpose()
print("first",payoff)
size=5
dr = np.ones(size)*1.0/size
army_combinations = np.identity(size)
lr = 0.01
def update():
    global power_table
    powers = np.zeros(len(army_combinations))
    grad_matrix = np.zeros(power_table.shape)

    for i,atk in enumerate(army_combinations):
        ap = np.outer(atk,dr)
        dp = np.outer(dr,atk)
        influence = ap-dp
        power = (power_table * influence).sum()
        powers[i] = power
        grad_matrix += influence * power


    err = (powers**2).sum()
    power_table -= lr*grad_matrix
    return err

def optimize():
    global payoff
    err = update()
    while err>0.0001:
        err = update()
    payoff = power_table - power_table.transpose()
    print("optimized powertable", power_table)
    print("optimized payoff", payoff)


# reward(payoff): (win, tie, lose)
def fight(p1_action, p2_action):
    powerdif = power_table[p1_action][p2_action] - power_table[p2_action][p1_action]
    return powerdif / 2

def test(steps=100, batch=1000,lr=0.001):
    nums = [0, 1, 2, 3, 4]
    strategy = [0.6, 0.2, 0.05, 0.05, 0.1]
    #strategy = [0.2, 0.2, 0.2, 0.2, 0.2]    # equal strategy
    x = []
    y = [[], [], [], [], []]
    addPoint(x, y, strategy)
    for step in range(steps):
        err = np.array([0, 0, 0, 0, 0])
        for i in nums:
            p1moves = random.choices(nums, strategy, k=batch)
            for j in p1moves:
                res = fight(i, j)
                err[i] += res

        grad = calcGrad(err, greedy=True)

        strategy = strategy - grad * lr
        strategy = intoProb(strategy)

        addPoint(x, y, strategy)

    print("strategy",strategy)
    plt.plot(x, y[0], label='unit1')
    plt.plot(x, y[1], label='unit2')
    plt.plot(x, y[2], label='unit3')
    plt.plot(x, y[3], label='unit4')
    plt.plot(x, y[4], label='unit5')

    plt.legend()
    plt.ylim(-0.03,1)
    plt.xlabel("iteration")
    plt.ylabel("probability")
    plt.show()

def calcGrad(err, greedy=True):
    if greedy:
        row = err.argmax()
        grad = payoff[row] * err.max()
    else:
        grad = [0, 0, 0, 0, 0]
        for i in range(5):
            grad += payoff[i] * err[i]

    return grad

def intoProb(vals):
    vals[vals<0]=0
    total = sum(vals)
    return vals/total

xctr=0
def addPoint(x,y,s):
    global xctr
    x.append(xctr)
    xctr = xctr+1
    y[0].append(s[0])
    y[1].append(s[1])
    y[2].append(s[2])
    y[3].append(s[3])
    y[4].append(s[4])


if __name__ == '__main__':
    np.set_printoptions(precision=2)
    main()
